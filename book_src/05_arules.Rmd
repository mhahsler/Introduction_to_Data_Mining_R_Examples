---
editor_options: 
  markdown: 
    wrap: 72
---

# Association Analysis: Basic Concepts

This chapter introduces association rules mining using the APRIORI
algorithm. In addition, analyzing sets of association rules 
using visualization techniques is demonstrated. 

The corresponding chapter of 
the data mining textbook is available online: 
[Chapter 5: Association Analysis: Basic Concepts and Algorithms.](https://mhahsler.github.io/Introduction_to_Data_Mining_R_Examples/DM_chapters/ch5_association_analysis.pdf)

### Packages Used in this Chapter {.unnumbered}

```{r setup_05}
pkgs <- c("arules", "arulesViz", "mlbench", 
          "palmerpenguins", "tidyverse")

pkgs_install <- pkgs[!(pkgs %in% installed.packages()[,"Package"])]
if(length(pkgs_install)) install.packages(pkgs_install)
```

```{r setup_05-2, include=FALSE}
source("_common.R")
source("format_pkgs.R")
all_pkgs <- union(all_pkgs, pkgs)
```

The packages used for this chapter are: 

`r format_pkgs(pkgs)`


## Preliminaries

[Association rule mining](https://en.wikipedia.org/wiki/Association_rule_learning) 
plays a vital role in discovering hidden patterns and relationships within large
transactional datasets. Applications range from exploratory data analysis in marketing to building rule-based
classifiers.
@arules:Agrawal+Imielinski+Swami:1993 introduced the problem
of mining association rules from transaction data as follows (the definition is taken from @arules:Hahsler+Gruen+Hornik:2005b):

Let $I = \{i_1,i_2,...,i_n\}$ be a set of $n$ binary attributes called items. Let $D = \{t_1,t_2,...,t_m\}$ be
a set of transactions called the database. Each transaction in $D$ has a unique transaction ID and
contains a subset of the items in $I$. A rule is defined as an implication of the form $X \Rightarrow Y$ where
$X,Y \subseteq I$ and $X \cap Y = \emptyset$ are called itemsets. On itemsets and rules several quality measures can
be defined. The most important measures are support and confidence. The support $supp(X)$ of
an itemset $X$ is defined as the proportion of transactions in the data set which contain the itemset.
Itemsets with a support which surpasses a user-defined threshold $\sigma$ are called frequent itemsets. The
confidence of a rule is defined as $conf(X \Rightarrow Y) = supp(X \cup Y)/supp(X)$. Association rules are rules
with $supp(X \cup Y) \ge \sigma$ and $conf(X) \ge \delta$ where $\sigma$ and $\delta$ are user-defined thresholds.
The found set of association rules is then used reason about the data.

You can read the free sample chapter from the textbook [@Tan2005]:
[Chapter 5. Association Analysis: Basic Concepts and
Algorithms](https://mhahsler.github.io/Introduction_to_Data_Mining_R_Examples/DM_chapters/ch5_association_analysis.pdf)

### The arules Package

Association rule mining in R is implemented in the package `arules`.

```{r }
library(tidyverse)
library(arules)
library(arulesViz)
```

For information about the `arules` package try: `help(package="arules")`
and `vignette("arules")` (also available at
[CRAN](http://cran.r-project.org/web/packages/arules/vignettes/arules.pdf))

arules uses the S4 object system to implement classes and methods.
Standard R objects use the [S3 object
system](http://adv-r.had.co.nz/S3.html) which do not use formal class
definitions and are usually implemented as a list with a class
attribute. `arules` and many other R packages use the [S4 object
system](http://adv-r.had.co.nz/S4.html) which is based on formal class
definitions with member variables and methods (similar to
object-oriented programming languages like Java and C++). Some important
differences of using S4 objects compared to the usual S3 objects are:

-   coercion (casting): `as(from, "class_name")`
-   help for classes: `class? class_name`

### Transactions

#### Create Transactions

We will use the Zoo dataset from `mlbench`.

```{r }
data(Zoo, package = "mlbench")
head(Zoo)
```

The data in the data.frame need to be converted into a set of
transactions where each row represents a transaction and each column is
translated into items. This is done using the constructor
`transactions()`. For the Zoo data set this means that we consider
animals as transactions and the different traits (features) will become
items that each animal has. For example the animal *antelope* has the
item *hair* in its transaction.

```{r }
trans <- transactions(Zoo)
```

The conversion gives a warning because only discrete features (`factor`
and `logical`) can be directly translated into items. Continuous
features need to be discretized first.

What is column 13?

```{r }
summary(Zoo[13])
ggplot(Zoo, aes(legs)) + geom_bar()
Zoo$legs |> table()
```

There are several ways how we can convert a continuous value into discrete items

#### Alternative Encodings for Continuous Values

**Alternative 1:** Make legs into has/does not have legs

```{r }
Zoo_has_legs <- Zoo |> mutate(legs = legs > 0)
ggplot(Zoo_has_legs, aes(legs)) + geom_bar()
Zoo_has_legs$legs |> table()
```

**Alternative 2:** Use each unique value as an item.

```{r }
Zoo_unique_leg_values <- Zoo |> mutate(legs = factor(legs))
Zoo_unique_leg_values$legs |> head()
```
**Alternative 3:** Use the discretize function (see
    [`? discretize`](https://www.rdocumentation.org/packages/arules/topics/discretize)
    and [discretization in the code for Chapter
    2](chap2.html#discretize-features)):

```{r }
Zoo_discretized_legs <- Zoo |> mutate(
  legs = discretize(legs, breaks = 2, method="interval")
)
table(Zoo_discretized_legs$legs)
```

In the following we will use **Alternative 1** where the legs item indicates if 
the animal has legs. We convert this data set into a set of transactions.

```{r }
trans <- transactions(Zoo_has_legs)
trans
```

#### Inspecting Transactions

It is very important to check that the conversion to transactions worked as 
intended.

```{r }
summary(trans)
```

Look at the created items. They are also called columns names since the
transactions are stored as a large, sparse logical matrix.

```{r }
colnames(trans)
```

Compare this to the original features (column names) from Zoo.

```{r }
colnames(Zoo)
```

We see that the nominal variable type was converted into several items, one for
each value.

We can also look at a (first) few transactions as a logical matrix. `TRUE` 
indicates the presence of an item.

```{r }
as(trans, "matrix")[1:3,]
```

The matrix is large. We can get a visual impression by plot the binary matrix
as an image. Dark dots represent items (`TRUE` values in the matrix).

```{r }
image(trans)
```

Since each transaction typically only contains a small number of items, 
it is often more convenient to inspect transactions as sets of items.

```{r }
inspect(trans[1:3])
```

It is often also interesting to 
look at the relative frequency (=support) of items in the data set. Here
we look at the 20 most frequent items.

```{r }
itemFrequencyPlot(trans,topN = 20)
```

The bar chart only works well for a small number of items.
The frequenct distribution over all items can also be shown as a line graph.

```{r }
ggplot(
  tibble(
    Support = sort(itemFrequency(trans, type = "absolute"), 
                   decreasing = TRUE),
    Item = seq_len(ncol(trans))
  ), aes(x = Item, y = Support)) + 
  geom_line()
```

#### Negative Items 

The typical transaction encoding focuses on items for features that the animals have. 
We can also create items for missing features (e.g., the animal does *not* lay eggs).
This can be easily done by converting the logical values into factors.
Now we have a nominal variable with thwo values which will be converted into two items.

```{r }
sapply(Zoo_has_legs, class)
Zoo_factors <- Zoo_has_legs |> 
  mutate(across(where(is.logical), factor))
sapply(Zoo_factors, class)
summary(Zoo_factors)

trans_factors <- transactions(Zoo_factors)
trans_factors

itemFrequencyPlot(trans_factors, topN = 20)

## Select transactions that contain a certain item
trans_insects <- trans_factors[trans %in% "type=insect"]
trans_insects
inspect(trans_insects)
```

#### Vertical Layout (Transaction ID Lists)

The default layout for transactions is horizontal layout (i.e. each
transaction is a row). The vertical layout represents transaction data
as a list of transaction IDs for each item (= transaction ID lists).

```{r }
vertical <- as(trans, "tidLists")
as(vertical, "matrix")[1:10, 1:5]
```

## Frequent Itemset Generation

Even for the small Zoo dataset, we have already a large number of possible itemsets.

```{r }
2^ncol(trans)
```

Finding frequent itemsets uses the parameter `target = "frequent"` (the default target
is to directly mine rules).

```{r }
its <- apriori(trans, parameter=list(target = "frequent"))
its
```

The default minimum support is .1 (10%). **Note:** The Zoo data set is very small with very few 
items. For larger datasets, the default minimum support might be too
low and you may run out of memory. You probably want to start out with a
higher minimum support like .5 (50%) and then work your way down.

We can calculate the support needed to find itemsets that effect at least 5 animals.

```{r }
5/nrow(trans)
```

This shows that we need to go down to a
minimum support of about 5%.

```{r }
its <- apriori(trans, parameter=list(target = "frequent", 
                                     support = 0.05))
its
```

We will get many itemsets. We can sort them by support, and show the top 10 itemsets.

```{r }
its <- sort(its, by = "support")
its |> head(n = 10) |> inspect()
```

We can also look at the largest frequent itemsets. Large means here many items.

```{r }
ggplot(tibble(`Itemset Size` = factor(size(its))), 
       aes(`Itemset Size`)) + 
  geom_bar()

its[size(its) > 8] |> inspect()
```


## Rule Generation

We use the APRIORI algorithm (see
[`? apriori`](https://www.rdocumentation.org/packages/arules/topics/apriori))

```{r }
rules <- apriori(trans, 
                 parameter = list(support = 0.05, 
                                  confidence = 0.9))
length(rules)
```

```{r }
rules |> head() |> inspect()
rules |> head() |> quality()
```

It is common to sort rules by the lift measure and inspect the rules with the largest lift.

```{r }
rules <- sort(rules, by = "lift")
rules |> head(n = 10) |> inspect()
```

We see that most high-lift rules are about fish. The reason may be since fish 
have very specific features that are very different from the other animal types
in the data.

As a comparison, we show next what rules are generated if we include 
negative items in the transactions.

```{r }
r <- apriori(trans_factors)
r
```

This encoding creates very dense data (i.e., each transaction contains many items).
This leads to finding many rules and may lead to the algorithm running out of memory.
This is how much memory the rule set uses.

```{r}
print(object.size(r), unit = "Mb")
```

Let's inspect the top 10 lift rules.

```{r }
inspect(r[1:10])
r |> head(n = 10, by = "lift") |> inspect()
```

The rules are similar, but now show 
that fish do not breathe (air) or give milk. It is often benficial to introduce
negative items for some features, but not for all.

### Additional Interest Measures

Many different interest measures can be calculated for existing rules
(or itemsets) using the function
`interestMeasure()`.

```{r }
interestMeasure(rules[1:10], measure = c("phi", "gini"),
  trans = trans)
```

To store the new interest measures with the rule set, we have 
to add them to the quality slot.

```{r }
quality(rules) <- cbind(quality(rules),
  interestMeasure(rules, measure = c("phi", "gini"),
    trans = trans))
```

Find rules which score high for Phi correlation between the LHS and RHS of the 
rule.

```{r }
rules |> head(by = "phi") |> inspect()
```

### Mine Using Templates

Sometimes it is beneficial to specify what items should be where in the found
rule. For` apriori()` we can use the parameter `appearance` to specify this
(see
[`? APappearance`](https://www.rdocumentation.org/packages/arules/topics/APappearance)).
In the following we restrict rules to an animal `type` in the RHS and
any item in the LHS. We first create all type related items.

```{r }
type <- grep("type=", itemLabels(trans), value = TRUE)
type
```

Now, we can restrict the appearance in the RHS.

```{r }
rules_type <- apriori(trans, appearance= list(rhs = type))
```

```{r}
rules_type |> sort(by = "lift") |> head() |> inspect()
```

### Redundant Rules

Association rule mining is prone to generate too many very specific rules.
A rule can be defined as redundant if a more general rules with the same 
or a higher confidence exists.

```{r}
rules_type
table(size(rules_type))
```

```{r }
rules_type_non_redundant <- rules_type[!is.redundant(rules_type)]
rules_type_non_redundant
table(size(rules_type_non_redundant))
```

```{r}
inspect(rules_type_non_redundant)
```
We see that this simple redundancy check results in a rule set of a manageable size
which can can be easily analyzed by a human.

### Saving Rules for External Tools

Rules can be saved as a CSV-file to be opened with Excel or other tools.

`write(rules, file = "rules.csv", quote = TRUE)`

Another option is to export rules in PMML (Predictive Model Markup Language) 
format. See `pmml()`.


## Compact Representation of Frequent Itemsets

An itemset is maximal in a set if no proper superset of the itemset is 
contained in the set. Since we are often interest in the most specific itemsets
with the largest number of items this is often useful for reducing the 
size of the set for manual inspection.

```{r }
its_max <- its[is.maximal(its)]
its_max
its_max |> head(by = "support") |> inspect()
```


Another compact representation is the idea of closed itemsets.
The closure of an itemset is its largest proper superset which has the same support (is contained in exactly the same transactions). An itemset is closed, if it is its own closure. 
This is similar to the idea of maximal itemsets but only removes itemsets if
a superset with the same support exists.

```{r }
its_closed <- its[is.closed(its)]
its_closed
```

```{r }
its_closed |> head(by = "support") |> inspect()
```

```{r}
counts <- c(
  frequent=length(its),
  closed=length(its_closed),
  maximal=length(its_max)
)
```

Here is a comparison of the number of frequent itemsets with closed and maximal 
itemsets.

```{r }
ggplot(as_tibble(counts, rownames = "Itemsets"),
  aes(Itemsets, counts)) + geom_bar(stat = "identity")
```


## Association Rule Visualization*

Visualization is a very powerful approach to analyse large sets of 
mined association rules and frequent itemsets. We present here some options
to create static visualizations and inspect rule sets interactively.

### Static Visualizations

Load the `arulesViz` library.

```{r }
library(arulesViz)
library(tidyverse)
```

Create rules for the Zoo dataset converting the legs variable into a binary 
indicator.

```{r }
data(Zoo, package = "mlbench")
Zoo_has_legs <- Zoo |> mutate(legs = legs > 0)
trans <- transactions(Zoo_has_legs)
trans
```

```{r}
rules <- apriori(trans, 
                 parameter = list(support = 0.05, 
                                  confidence = 0.9))

quality(rules) <- cbind(quality(rules),
  interestMeasure(rules, measure = c("phi", "gini"),
    trans = trans))

rules
```


#### Scatterplot
The default plot for association rules is a support/confidence scatterplot.

```{r }
plot(rules)
```

Each rules is represented by a point. Note that some jitter (randomly move points) 
was added to show how many
rules have the same confidence and support value. Without jitter:

```{r }
plot(rules, control = list(jitter = 0))

plot(rules, shading = "order")
```

#### Grouped Matrix Plot
The grouped matrix plot tries to group rules with a similar relationship between the rule's LHS and RHS and 
represents the groups support and lift using a balloon plot. 
Grouping is performed using clustering. Groups are organized such 
that the most interesting rules appear to the top left corner.  

```{r fig.height=7}
set.seed(1234)
plot(rules, method = "grouped matrix")
```

The most interesting rules are about thre relationship between fins, eggs and 5 more 
items and the type fish.


This plot can also be used interactively using the parameter 
`engine = "interactive"`.

#### Gaph-based Visualization
Graph-based techniques visualize association rules using vertices and edges,
where vertices typically represent items or itemsets and edges indicate relationships
in terms of rules. Interest measures are typically added to the plot as labels on the
edges or by color or width of the arrows displaying the edges.


```{r }
plot(rules, method = "graph")
plot(rules |> head(by = "phi", n = 100), method = "graph")
```
We see that the automatic graph layout organizes the rules roughly into three groups 
representing the three most frequent animal types: birds, mammals and fish.
we can also see that birds and mammals share items like breathes while birds and 
fish share eggs.


### Interactive Visualizations

Interactive visualizations let the user explore the large number of 
rules and itemsets and learn about the structure of the data. The overview article
[arulesViz: Interactive Visualization of Association Rules with R](https://journal.r-project.org/archive/2017/RJ-2017-047/RJ-2017-047.pdf)
provides an in-depth discussion of interactive association rule visualization.


We will use the association rules mined from the Iris dataset for the
following examples.

```{r }
data(iris)
summary(iris)
```

Convert the data to transactions. 

```{r }
iris_trans <- transactions(iris)
```
Note that this conversion gives a warning to indicate that some potentially 
unwanted conversion happens. Some features are numeric and
need to be discretized. The conversion automatically applies
frequency-based discretization with 3 classes to each numeric feature,
however, the use may want to use a different discretization strategy.

```{r}
iris_trans |> head() |> inspect()
```

Next, we mine association rules.

```{r }
rules <- apriori(iris_trans, parameter = list(support = 0.1, 
                                              confidence = 0.8))
rules
```

#### Interactive Inspect With Sorting, Filtering and Paging

An interactive table that lets the user sort and filter the rules
is a very effective exploration tool. We can quickly find the highest 
lift rules and filter by interesting items in the LHS and RHS of the rules.

```{r eval = knitr::is_html_output()}
inspectDT(rules,options = list(scrollX = TRUE))
```

```{r eval = !knitr::is_html_output(), echo=FALSE, results='asis'}
cat('_The resulting interactive table can be seen in the [online version of this book.](https://mhahsler.github.io/Introduction_to_Data_Mining_R_Examples/book/association-analysis-basic-concepts-and-algorithms.html#interactive-visualizations)_')
```

#### Scatter Plot

Plot rules as a scatter plot using an interactive html widget. To avoid
overplotting, jitter is added automatically. Set `jitter = 0` to disable
jitter. Hovering over rules shows rule information. *Note:*
plotly/javascript does not do well with too many points, so plot selects
the top 1000 rules with a warning if more rules are supplied.

```{r eval = knitr::is_html_output()}
plot(rules, engine = "html")
```

```{r eval = !knitr::is_html_output(), echo=FALSE, results='asis'}
cat('_The resulting interactive plot can be seen in the [online version of this book.](https://mhahsler.github.io/Introduction_to_Data_Mining_R_Examples/book/association-analysis-basic-concepts-and-algorithms.html#interactive-visualizations)_')
```

#### Matrix Visualization

The rules are organized in a matrix where the columns represent unique LHS itemsets and
the rows are the RHS items.  Hovering over rules shows rule information.


```{r eval = knitr::is_html_output()}
plot(rules, method = "matrix", engine = "html") 
```


```{r eval = !knitr::is_html_output(), echo=FALSE, results='asis'}
cat('_The resulting interactive plot can be seen in the [online version of this book.](https://mhahsler.github.io/Introduction_to_Data_Mining_R_Examples/book/association-analysis-basic-concepts-and-algorithms.html#interactive-visualizations)_')
```


#### Visualization as Graph

Plot rules as an interactive graph with items as rectangular vertices and rules as circular vertices.
Hovering over a vertex shows additional information. On most devices, the mouse wheel 
lets the user zoom in and out of the graph.
*Note:* the used
javascript library does not do well with too many graph nodes, so plot
selects the top 100 rules only (with a warning).

```{r eval = knitr::is_html_output()}
plot(rules, method = "graph", engine = "html")
```


```{r eval = !knitr::is_html_output(), echo=FALSE, results='asis'}
cat('_The resulting interactive plot can be seen in the [online version of this book.](https://mhahsler.github.io/Introduction_to_Data_Mining_R_Examples/book/association-analysis-basic-concepts-and-algorithms.html#interactive-visualizations)_')
```

#### Interactive Rule Explorer

You can specify a rule set or a dataset. To explore rules that can be
mined from iris, use: `ruleExplorer(iris)`

The rule explorer creates an interactive Shiny application that can be
used locally or deployed on a server for sharing. A deployed version of
the ruleExplorer is available
[here](https://mhahsler-apps.shinyapps.io/ruleExplorer_demo/) (using
[shinyapps.io](https://www.shinyapps.io/)).

## Exercises*

We will again use the Palmer penguin data for the exercises.

```{r }
library(palmerpenguins)
head(penguins)
```

1. Translate the penguin data into transaction data with:
  ```{r }
  trans <- transactions(penguins)
  trans
  ```
  Why does the conversion report warnings? 
  
2. What do the following first three transactions mean?
  ```{r }
  inspect(trans[1:3])
  ```

Next, use the `ruleExplorer()` function to analyze association rules
created for the transaction data set.

1. Use the default settings for the parameters. 
  Using the _Data Table_, what is the association rule with the highest lift. What does its LHS, RHS,
  support, confidence and lift mean?
  
2. Use the _Graph_ visualization. Use select by id to highlight different species and
  different islands and then hover over some of the rules. What do you see?

